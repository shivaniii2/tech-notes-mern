JWT (JSON Web Token) is a compact and self-contained way of securely transmitting information between parties as a JSON object.
A JWT is a specific type of token format, commonly used for access tokens.
A JWT is composed of three parts, which are base64-encoded ,separated by dots (.), and looks like this: 

base64(Header) + "." + base64(Payload) + "." + Signature


1. Header  : This part contains metadata about the token, typically specifying the type of token (JWT) and the signing algorithm (e.g., HMAC, SHA256).

2. Payload : This part contains the claims or data being shared, such as user information.

3. Signature : Its primary purpose is to ensure the token's integrityâ€”that is, to guarantee that the token hasn't been tampered with after it was created and signed



The jwt.sign method is used to create a JWT (JSON Web Token)


Let us understand how :

The header is automatically generated by the jsonwebtoken library based on the algorithm you use. If you don't specify it explicitly, it defaults to something like this:

{
  "alg": "HS256",  // Algorithm used for signing (HMAC SHA256 in this case)
  "typ": "JWT"     // Token type, which is JWT
}


The payload is the object you pass as the first argument in jwt.sign():

{
    "UserInfo": {
        "username": foundUser.username,
        "roles": foundUser.roles
    }
}



The signature is generated internally by combining the base64-encoded header and payload, using the secret you provide (process.env.ACCESS_TOKEN_SECRET). This ensures that the token hasn't been tampered with.

Let us understand how :

require('crypto').randomBytes(64).toString('hex') generates a random sequence of bytes, typically used to create a secret key for signing JWTs.



In JWT (JSON Web Token), the header and payload are base64-encoded, not encrypted. Base64 encoding is simply a way to represent binary data (like JSON objects) as ASCII strings, which can be safely transmitted over HTTP.

Encoding: Both the header and payload are JSON objects, and they are base64-encoded into a format that can be included in a URL.

payload before encoding :

{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}


payload after encoding :
Header (base64-encoded): eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
At this point, no cryptographic security is involved yet. Anyone can decode the header and payload from base64 back into their original JSON form.



 Signing the JWT (Using the Secret Key)  :
 This is where the secret key comes into play.

After the header and payload are encoded, they are concatenated together like this:
base64(Header) + "." + base64(Payload)

The secret key generated by require('crypto').randomBytes(64).toString() (a 64-byte random string) is used to sign this concatenated string. Signing ensures the token's integrity by applying a cryptographic algorithm, usually HMAC SHA-256 (HS256).


The signing process looks like this:

Signature = HMACSHA256(base64(Header) + "." + base64(Payload), secret_key)
The secret key is fed into the HMAC algorithm to produce a signature based on the header and payload.

Once the signature is generated, the final JWT looks like this:
base64(Header) + "." + base64(Payload) + "." + Signature



When a JWT is received by the server, it does the following to verify the token:

It extracts the header, payload, and signature from the JWT string.

It recomputes the signature using the same method (HMAC SHA-256) and the same secret key that was used to generate the token.

The server takes the received base64(Header) and base64(Payload) and generates a signature using the secret key.
It compares the recomputed signature with the one received in the token. If they match, the token is valid and has not been altered.

If the signatures do not match, it means the token has been tampered with, and the server will reject the token.




Access Token: Credential for authorizing access, often a JWT.
JWT: A self-contained token format with a header, payload, and signature.
Signature: Ensures the token has not been tampered with.
Secret Key: Used to create the signature and validate the token.



learnt today about these four new methods :
1. jwt.sign () 

jwt sign is used to create a new access token of jwt format .
It takes headers , payload , secretkey as arguments


2. jwt.verify ()
 This is a method provided by the jsonwebtoken library in Node.js to verify and decode a JSON Web Token (JWT). It checks the token's validity and authenticity based on a secret or public key and returns the decoded payload if the token is valid.
jwt.verify(token, secretOrPublicKey, [options, callback])

